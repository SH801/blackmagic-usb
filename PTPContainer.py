# -LICENSE-START-
# Copyright (c) 2020 Blackmagic Design
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# -LICENSE-END-
# 

import fixedint
from BaseEnum import *
from UtilityFunctions import *
from PTPTypes import *

ContainerTypeType = fixedint.UInt16
class ContainerData:

	class ContainerType(BaseEnum):
		Undefined 		= ContainerTypeType(0)
		CommandBlock 	= ContainerTypeType(1)
		DataBlock 		= ContainerTypeType(2)
		ResponseBlock 	= ContainerTypeType(3)
		EventBlock 		= ContainerTypeType(4)

	def __init__(self):
		self.length 		= fixedint.UInt32(PTPTypes.kContainerHeaderSize)
		self.type			= ContainerData.ContainerType.Undefined
		self.code			= fixedint.UInt16(0)	# Can be operation, response, or event codes
		self.transactionId	= TransactionID(PTPTypes.kInvalidCaptureTransactionId)
		self.payload 		= bytearray(PTPTypes.kMaxPayloadSize)

	def serialize(self):
		byteArray = bytearray(0)
		byteArray += UtilityFunctions.ToByteArray(self.length)
		byteArray += UtilityFunctions.ToByteArray(ContainerTypeType(self.type.value))
		byteArray += UtilityFunctions.ToByteArray(self.code)
		byteArray += UtilityFunctions.ToByteArray(self.transactionId)

		payloadSize = fixedint.Int32(self.length) - PTPTypes.kContainerHeaderSize
		byteArray += self.payload[:payloadSize]
		
		return byteArray
	
	def deserialize(self, data) -> bool:
		index = 0
		size = MemoryLayout.size(self.length)
		self.length = fixedint.UInt32(UtilityFunctions.FromByteArray(data[index:(index + size)]))
		index += size

		if 		(self.length < PTPTypes.kContainerHeaderSize) \
			| 	(self.length > PTPTypes.kMaxPacketSize) \
			| 	(self.length > len(data)):
			return False
		
		size = MemoryLayout.size(self.type.value)
		value = ContainerTypeType(UtilityFunctions.FromByteArray(data[index:(index + size)]))
		if value not in ContainerData.ContainerType: return False
		self.type = ContainerData.ContainerType(value)
		index += size

		size = MemoryLayout.size(self.code)
		self.code = fixedint.UInt16(UtilityFunctions.FromByteArray(data[index:(index + size)]))
		index += size
		
		size = MemoryLayout.size(self.transactionId)
		self.transactionId = TransactionID(UtilityFunctions.FromByteArray(data[index:(index + size)]))
		self.payload[:] = data[PTPTypes.kContainerHeaderSize:]

		return True

class Container:
	
	def __init__(self):
		self.m_containerData = ContainerData()

	def reset(self):
		self.m_containerData = ContainerData()
	
	def serializeContainerDataToByteArray(self):
		return self.m_containerData.serialize()
	
	def deserializeContainerDataFromByteArray(self, data) -> bool:
		if len(data) < PTPTypes.kContainerHeaderSize: return False
		
		self.reset()
		
		return self.m_containerData.deserialize(data)
	
	# Doesn't appear to be used anywhere
	def appendToEndOfPayload(self, value):
		byteArray = UtilityFunctions.ToByteArray(value)
		payloadSize:fixedint.Int32 = fixedint.Int32(self.m_containerData.length - PTPTypes.kContainerHeaderSize)
		self.m_containerData.payload[payloadSize:payloadSize] = byteArray	
		self.m_containerData.length += fixedint.UInt32(len(byteArray))
