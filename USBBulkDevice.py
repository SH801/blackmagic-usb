# -LICENSE-START-
# Copyright (c) 2020 Blackmagic Design
# 
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
# 
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# -LICENSE-END-
#

import fixedint
from typing import List
import usb1
from LogFunctions import *
from USBDevice import *

class USBBulkDevice(USBDevice):
	
	def __init__(	self,
	      			usbContext: usb1.USBContext,	      
	      			id: fixedint.UInt64, 
	      			vendorId: fixedint.UInt16, 
					productId: fixedint.UInt16, 
					name, 
					deviceInterface: USBDeviceInterface, 
					interfaceNumber,
					interfaceSetting: USBInterfaceSetting):
		super().__init__(usbContext, id, vendorId, productId, name, deviceInterface)
		self.m_interfaceNumber 			= interfaceNumber
		self.m_interfaceSetting 		= interfaceSetting
		self.m_endpointBulkOutRef 		= fixedint.UInt8(0)
		self.m_endpointBulkInRef 		= fixedint.UInt8(0)
		self.m_endpointInterruptInRef 	= fixedint.UInt8(0)
		self.m_interfaceOpened 			= False

	def open(self) -> bool:
		Logger.LogWithInfo("open: started")

		if self.m_interfaceNumber is None:
			Logger.LogError("Unable to get USB Interface type PTP")
			return False

		if self.m_interfaceSetting is None:
			Logger.LogError("Unable to get USBInterfaceSetting")
			return False
		
		try:
			self.m_deviceHandle = self.m_deviceInterface.open()
		except usb1.USBError:
			Logger.LogError("Unable to open USB device")
			return False

		try:
			self.m_deviceHandle.claimInterface(self.m_interfaceNumber)
		except usb1.USBError:
			Logger.LogError("Unable to claim interface {} on USB device".format(self.m_interfaceNumber))
			return False
		
		for endpoint in self.m_interfaceSetting.iterEndpoints():
			maxPacketSize = endpoint.getMaxPacketSize()
			interval = endpoint.getInterval()
			transferType = endpoint.getAttributes()
			address = endpoint.getAddress()
			direction = usb1.ENDPOINT_OUT if (address & usb1.ENDPOINT_DIR_MASK) == 0 else usb1.ENDPOINT_IN

			if (direction == usb1.ENDPOINT_OUT) & (transferType == usb1.TRANSFER_TYPE_BULK):
				Logger.LogWithInfo("Bulk Out endpoint ref = {}, max packet size = {}".format(hex(address), maxPacketSize))
				self.m_endpointBulkOutRef = address
			elif (direction == usb1.ENDPOINT_IN) & (transferType == usb1.TRANSFER_TYPE_BULK):
				Logger.LogWithInfo("Bulk In endpoint ref = {}, max packet size = {}".format(hex(address), maxPacketSize))
				self.m_endpointBulkInRef = address
			elif (transferType == usb1.TRANSFER_TYPE_INTERRUPT):
				Logger.LogWithInfo("Bulk interrupt endpoint ref = {}".format(hex(address)))
				self.m_endpointInterruptInRef = address

		Logger.LogWithInfo("open: finished")

		self.m_interfaceOpened = True
		return True
	
	def close(self):
		Logger.LogWithInfo("close: started")

		if self.m_interfaceNumber is None:
			Logger.LogError("Unable to get USB Interface number")
			return False

		if self.m_deviceHandle is None:
			Logger.LogError("Unable to get USB device handle")
			return False

		try:
			self.m_deviceHandle.releaseInterface(self.m_interfaceNumber)
			self.m_interfaceNumber = None
		except usb1.USBError:
			Logger.LogError("Unable to release interface {} on USB device".format(self.m_interfaceNumber))
			return False

		try:
			self.m_deviceHandle = self.m_deviceInterface.close()
			self.m_deviceHandle = None
		except usb1.USBError:
			Logger.LogError("Unable to close USB device")
			return False		

		Logger.LogWithInfo("close: finished")

		self.m_interfaceOpened = False
	
	def clearPipeStall(self):
		Logger.LogError("clearPipeStall - not healthy!")

		if self.m_deviceHandle is not None:
			try:
				self.m_deviceHandle.ResetDevice()
				Logger.Log("Successfully ResetDevice()")
			except usb1.USBError:
				# If this fails, will result in a device disconnect & reconnect, so you
    		    # have to close current device and rediscover it (notified by an
        		# USBErrorNotFound exception).
				Logger.LogError("Failed to ResetDevice()")
	
	def writePipe(self, buffer: List[fixedint.UInt8]) -> bool:

		if self.m_deviceHandle is None:
			Logger.LogError("Unable to get USB device handle")
			return False
		
		if self.m_endpointBulkOutRef == 0:
			Logger.LogError("USB interface does not have a bulk OUT endpoint")
			return False
				
		packetCopy = bytearray(len(buffer))
		packetCopy[:] = buffer

		try:
			result = self.m_deviceHandle.bulkWrite(self.m_endpointBulkOutRef, packetCopy, 500)	
			return True if result == len(buffer) else False			
		except usb1.USBErrorTimeout:
			self.clearPipeStall()
			return False
	
	def readPipe(self, size):

		if self.m_deviceHandle is None:
			Logger.LogError("Unable to get USB device handle")
			return False
		
		if self.m_endpointBulkInRef == 0:
			Logger.LogError("USB interface does not have a bulk IN endpoint")
			return False
				
		try:
			return self.m_deviceHandle.bulkRead(self.m_endpointBulkInRef, size, 500)	
		except usb1.USBError:
			Logger.LogError("Failed to read endpoint")
			return False
	
	def readInterruptPipe(self, size):
		
		if self.m_deviceHandle is None:
			Logger.LogError("Unable to get USB device handle")
			return False
		
		if self.m_endpointInterruptInRef == 0:
			Logger.LogError("USB interface does not have a bulk INTERRUPT endpoint")
			return False
				
		try:
			return self.m_deviceHandle.bulkRead(self.m_endpointInterruptInRef, size)	
		except usb1.USBError:
			Logger.LogError("Failed to read endpoint")
			return False
