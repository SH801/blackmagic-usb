# -LICENSE-START-
# Copyright (c) 2018 Blackmagic Design
# 
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
# 
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# -LICENSE-END-
#

import fixedint
from queue import Queue, Empty as QueueEmpty
from LogFunctions import *
from BaseEnum import *
from CCUPacketTypes import *
from VideoConfig import *
from TransportInfo import *
from USBBulkDevice import *
from USBPTPController import *
from CameraState import *
from USBConnectionManager import *

ConnectionStatusFlagsType = fixedint.UInt8
class ConnectionStatusFlags(BaseEnum):
	kNone                   = ConnectionStatusFlagsType(0x00)
	kPower                  = ConnectionStatusFlagsType(0x01)
	kConnected              = ConnectionStatusFlagsType(0x02)
	kPaired                 = ConnectionStatusFlagsType(0x04)
	kVersionsVerified       = ConnectionStatusFlagsType(0x08)
	kInitialPayloadReceived = ConnectionStatusFlagsType(0x10)
	kCameraReady            = ConnectionStatusFlagsType(0x20)

class CameraControlInterface:

	def __init__(self, usbcontext):

		self.m_usbPtpInterface:USBPTPController = None
		self.m_shutterValueIsAngle:bool         = True
		self.m_sensorGainIsISO:bool             = True
		self.m_connectionStatus:fixedint.UInt8  = 0
		self.m_cameraState                      = CameraState()
		self.m_usbConnectionManager             = USBConnectionManager(usbcontext)
		self.m_usbConnectionManager.setDelegate(self)
		self.m_focusSetEvent 					= threading.Event()
		self.m_notificationLoop					= None
		self.m_notificationQueue				= None

		# Caching slot data in case remainingTime/MediaStatus CCU messages arrive before slots are initialized through transportInfo message received
		self.cachedSlotData                     = { 'recordTimeRemaining': None, 'mediaStatus': None }

	def setNotificationQueue(self, loop, notificationQueue):
		self.m_notificationLoop = loop
		self.m_notificationQueue = notificationQueue

	def sendNotification(self, data):
		if self.m_notificationQueue is not None:
			self.m_notificationLoop.call_soon_threadsafe(self.m_notificationQueue.put_nowait, data)

	def stop(self):
		# self.disconnectedFromUSBDevice()

		if self.m_usbConnectionManager is not None:
			Logger.LogWithInfo("CameraControlInterface: Stopping USBConnectionManager notifier")
			self.m_usbConnectionManager.stop()	
			self.m_usbConnectionManager = None

		Logger.LogWithInfo("CameraControlInterface: USBConnectionManager shutdown")	

	def __enter__(self):
		return self
	
	def __exit__(self, exc_type, exc_value, traceback):
		self.stop()

	def updateDiscoveredUSBPTPDevices(self, usbPTPDevices: List[USBBulkDevice]): 
		Logger.LogInfo("CameraControlInterface: updateDiscoveredUSBPTPDevices")
		if (self.isConnected() is False) & (len(usbPTPDevices) != 0):
			Logger.LogInfo("CameraControlInterface: not connected to any devices so attempting connection")
			self.connectToPTPDevice(usbPTPDevices[0])
	
	def connectedToUSBDevice(self, usbPTPDevice: USBBulkDevice):
		Logger.LogInfo("CameraControlInterface: connectedToUSBDevice")

		self.m_usbPtpInterface = USBPTPController(usbPTPDevice)
		Logger.LogInfo("CameraControlInterface: instantiated USBPTPController")

		self.m_usbPtpInterface.setPacketDecodedDelegate(self)
		self.m_connectionStatus |= ConnectionStatusFlags.kConnected.value
		
		Logger.LogInfo("CameraControlInterface: Connected to {}".format(usbPTPDevice.getName()))
			
	def disconnectedFromUSBDevice(self):
		Logger.LogInfo("CameraControlInterface: disconnectedFromUSBDevice")
		if self.m_usbPtpInterface is not None:
			self.m_usbPtpInterface.stop()
			self.m_usbPtpInterface = None
		self.m_connectionStatus = ConnectionStatusFlags.kNone
	
	def onResponseReceived(self, transactionId: TransactionID, responseCode: ResponseCode):
		Logger.LogInfo("CameraControlInterface: onResponseReceived")

	def onDataReceived(self, dataContainer: Container):
		Logger.LogInfo("CameraControlInterface: onDataReceived")
	
	def onDevicePropDescReceived(self, devicePropDesc: PTPDevicePropDesc):
		Logger.LogInfo("CameraControlInterface: onDevicePropDescReceived")
	
	def onNDFilterReceived(self, stops: float):
		Logger.LogInfo("CameraControlInterface: onNDFilterReceived")

	def onDevicePropertyChanged(self, devicePropCode: DevicePropCode):
		Logger.LogInfo("CameraControlInterface: onDevicePropertyChanged")
	
	def onDevicePropertyDescriptionChanged(self, devicePropCode: DevicePropCode):
		Logger.LogInfo("CameraControlInterface: onDevicePropertyChanged")
	
	def onRecordingStarted(self):
		Logger.LogInfo("CameraControlInterface: onRecordingStarted")
		self.m_cameraState.hasRecordingError = self.m_cameraState.anyMediaWithError

	def onRecordingStopped(self):
		Logger.LogInfo("CameraControlInterface: onRecordingStopped")

	def getPeripheralName(self) -> str:
		Logger.LogInfo("CameraControlInterface: getPeripheralName")
		if self.m_usbPtpInterface is None: return "No camera connected"
		name = self.m_usbPtpInterface.getDevice().getName()
		return name if name is not None else "Blackmagic Design Camera"

	def getCameraModel(self) -> CameraModel:
		Logger.LogInfo("CameraControlInterface: getCameraModel")
		return self.m_cameraState.cameraModel

	def connectToPTPDevice(self, usbBulkDevice: USBBulkDevice):
		Logger.LogInfo("CameraControlInterface: connectToPTPDevice")
		if self.m_usbConnectionManager.openDevice(usbBulkDevice):
			Logger.LogWithInfo("CameraControlInterface: openDevice complete")			
			if self.m_usbPtpInterface.openSessionWithforceClosePreviousSessionIfPresent(True):
				Logger.LogWithInfo("CameraControlInterface: Successfully connected to PTP device")
			else:
				Logger.LogError("CameraControlInterface: Failed to connect to PTP device")

	def disconnect(self):
		Logger.LogInfo("CameraControlInterface: disconnect")
		# Disconnect from any connections
		if self.m_usbPtpInterface is not None:
			self.m_usbConnectionManager.closeDevice()

	def isConnected(self) -> bool:
		return (self.m_connectionStatus & ConnectionStatusFlags.kConnected.value) != 0

	def onWhiteBalanceKelvinReceived(self, whiteBalance: fixedint.Int16):
		self.onWhiteBalanceReceived(whiteBalance, self.m_cameraState.tint)

	def onWhiteBalanceTintReceived(self, tint: fixedint.Int16):
		self.onWhiteBalanceReceived(self.m_cameraState.whiteBalance, tint)

	def onWhiteBalanceReceived(self, whiteBalance: fixedint.Int16, tint: fixedint.Int16):
		Logger.LogInfo("CameraControlInterface: onWhiteBalanceReceived wb:{} tint:{}".format(whiteBalance, tint))		
		self.m_cameraState.whiteBalance = whiteBalance
		self.m_cameraState.tint = tint
		self.sendNotification({'parameter': 'whitebalance', 'value': [whiteBalance, tint]})
				
	def updateIrisAndShutterControl(self):
		autoExposureMode = self.m_cameraState.autoExposureMode
		manualIris = (autoExposureMode == CCUPacketTypes.AutoExposureMode.Manual) | (autoExposureMode == CCUPacketTypes.AutoExposureMode.Shutter)
		manualShutter = (autoExposureMode == CCUPacketTypes.AutoExposureMode.Manual) | (autoExposureMode == CCUPacketTypes.AutoExposureMode.Iris)
		lensAttached = (self.m_cameraState.fstop > 0) & LensConfig.IsApertureNormalisedValid(self.m_cameraState.apertureNormalised)

	def onApertureFstopReceived(self, fstop: float, stopUnits: LensConfig.ApertureUnits):
		Logger.LogInfo("CameraControlInterface: onApertureFstopReceived {}".format(fstop))				
		self.m_cameraState.fstop = fstop
		self.m_cameraState.stopUnits = stopUnits
		self.sendNotification({'parameter': 'aperture', 'value': fstop})

		self.updateIrisAndShutterControl()

	def onApertureNormalisedReceived(self, apertureNormalised: float):
		Logger.LogInfo("CameraControlInterface: onApertureNormalisedReceived")				
		self.m_cameraState.apertureNormalised = apertureNormalised

		if LensConfig.IsApertureNormalisedValid(apertureNormalised):
			Logger.LogWithInfo("Received valid aperturNormalised {}".format(apertureNormalised))

	def onExposureReceived(self, exposure: fixedint.Int32):
		Logger.LogInfo("CameraControlInterface: onExposureReceived")						
	
	def onShutterSpeedReceived(self, shutterSpeed: fixedint.Int32):
		Logger.LogInfo("CameraControlInterface: onShutterSpeedReceived")						
		self.m_shutterValueIsAngle = False
		self.m_cameraState.shutterSpeed = shutterSpeed
		self.sendNotification({'parameter': 'shutterspeed', 'value': shutterSpeed})
	
	def onShutterAngleReceived(self, shutterAngleX100: fixedint.Int32):
		Logger.LogInfo("CameraControlInterface: onShutterAngleReceived")						
		self.m_shutterValueIsAngle = True
		self.m_cameraState.shutterAngle = float(shutterAngleX100) / 100.0
		self.sendNotification({'parameter': 'shutterangle', 'value': shutterAngleX100})

	def onISOReceived(self, iso: fixedint.Int32):		
		Logger.LogInfo("CameraControlInterface: onISOReceived {}".format(iso))						
		self.m_sensorGainIsISO = True
		self.m_cameraState.ISO = iso
		self.sendNotification({'parameter': 'iso', 'value': iso})
					
	def onGainReceived(self, decibels: Decibels):
		Logger.LogInfo("CameraControlInterface: onGainReceived")						
		self.m_sensorGainIsISO = False
		self.m_cameraState.gain = decibels
				
	def onDeviceInfoReceived(self, deviceInfo: PTPDeviceInfo):
		Logger.LogInfo("CameraControlInterface: onGainReceived")						
		self.m_cameraState.cameraModel = CameraModel.camerafromName(deviceInfo.m_model)
			
	def onBatteryLevelReceived(self, percentage: fixedint.UInt8):
		Logger.LogInfo("CameraControlInterface: onBatteryLevelReceived")								

	def onRecordingResolutionReceived(self, width: fixedint.Int16, height: fixedint.Int16):
		Logger.LogInfo("CameraControlInterface: onRecordingResolutionReceived")								
		self.m_cameraState.recordingFormatData.width = width
		self.m_cameraState.recordingFormatData.height = height

	def onFrameRateReceived(self, frameRate: fixedint.Int16):
		transformFrameRate = float(frameRate / 100)
		Logger.LogInfo("CameraControlInterface: onFrameRateReceived {}".format(transformFrameRate))	
		self.onOffSpeedFrameRateReceived(frameRate)	
		self.sendNotification({'parameter': 'framerate', 'value': transformFrameRate})

	def onOffSpeedFrameRateReceived(self, offSpeedFrameRate: fixedint.Int16):
		Logger.LogInfo("CameraControlInterface: onOffSpeedFrameRateReceived")								
		self.m_cameraState.recordingFormatData.offSpeedFrameRate = offSpeedFrameRate
	
	def onOffSpeedEnabledReceived(self, enabled: bool):
		Logger.LogInfo("CameraControlInterface: onOffSpeedEnabledReceived")								
		self.m_cameraState.recordingFormatData.offSpeedEnabled = enabled

	# OutgoingCameraControlFromUIDelegate methods

	# White Balance
	def onWhiteBalanceIncremented(self):
		Logger.LogInfo("CameraControlInterface: onWhiteBalanceIncremented")								
		newWhiteBalance: fixedint.Int16 = self.m_cameraState.whiteBalance + VideoConfig.kWhiteBalanceStep
		if newWhiteBalance > VideoConfig.kWhiteBalanceMax:
			newWhiteBalance = VideoConfig.kWhiteBalanceMin
		self.onWhiteBalanceChanged(newWhiteBalance)

	def onWhiteBalanceDecremented(self):
		Logger.LogInfo("CameraControlInterface: onWhiteBalanceDecremented")								
		newWhiteBalance: fixedint.Int16 = self.m_cameraState.whiteBalance - VideoConfig.kWhiteBalanceStep
		if newWhiteBalance < VideoConfig.kWhiteBalanceMin:
			newWhiteBalance = VideoConfig.kWhiteBalanceMax
		self.onWhiteBalanceChanged(newWhiteBalance)

	def onWhiteBalanceChanged(self, whiteBalance: fixedint.Int16):		
		Logger.LogInfo("CameraControlInterface: onWhiteBalanceChanged")								
		self.m_usbPtpInterface.writeWhiteBalance(fixedint.UInt16(whiteBalance))

	# Tint
	def onTintIncremented(self):
		Logger.LogInfo("CameraControlInterface: onTintIncremented")								
		newTint = self.m_cameraState.tint + 1
		if newTint > VideoConfig.kTintMax: newTint = VideoConfig.kTintMin
		self.onTintChanged(newTint)

	def onTintDecremented(self):
		Logger.LogInfo("CameraControlInterface: onTintDecremented")								
		newTint = self.m_cameraState.tint - 1
		if newTint < VideoConfig.kTintMin: newTint = VideoConfig.kTintMax
		self.onTintChanged(newTint)

	def onTintChanged(self, tint: fixedint.Int16):
		Logger.LogInfo("CameraControlInterface: onTintChanged")								
		self.m_usbPtpInterface.writeTint(fixedint.Int8(tint))
		
	def onAutoWhiteBalancePressed(self):
		Logger.LogInfo("CameraControlInterface: onAutoWhiteBalancePressed")								
		self.m_usbPtpInterface.enableAutoWhiteBalance()

	# Off-Speed Frame Rate
	def onOffSpeedFrameRateToggled(self, offSpeedEnabled: bool):
		Logger.LogInfo("CameraControlInterface: onOffSpeedFrameRateToggled")								
		self.m_cameraState.recordingFormatData.offSpeedEnabled = offSpeedEnabled		
		self.m_usbPtpInterface.writeOffSpeedEnabled(offSpeedEnabled)

	def onOffSpeedFrameRateIncremented(self) -> fixedint.Int16:
		Logger.LogInfo("CameraControlInterface: onOffSpeedFrameRateIncremented")								
		frameRateMin = VideoConfig.kOffSpeedFrameRateMin[self.m_cameraState.cameraModel] \
			if self.m_cameraState.cameraModel in VideoConfig.kOffSpeedFrameRateMin \
			else VideoConfig.kOffSpeedFrameRateMin[CameraModel.Unknown]
		frameRateMax = VideoConfig.kOffSpeedFrameRateMax[self.m_cameraState.cameraModel] \
			if self.m_cameraState.cameraModel in VideoConfig.kOffSpeedFrameRateMax \
			else VideoConfig.kOffSpeedFrameRateMax[CameraModel.Unknown]
		newOffSpeedFrameRate = self.m_cameraState.recordingFormatData.offSpeedFrameRate + 1
		
		if newOffSpeedFrameRate > frameRateMax: newOffSpeedFrameRate = frameRateMin

		self.onOffSpeedFrameRateChanged(newOffSpeedFrameRate)
		return newOffSpeedFrameRate

	def onOffSpeedFrameRateDecremented(self) -> fixedint.Int16:
		Logger.LogInfo("CameraControlInterface: onOffSpeedFrameRateDecremented")								
		frameRateMin = VideoConfig.kOffSpeedFrameRateMin[self.m_cameraState.cameraModel] \
			if self.m_cameraState.cameraModel in VideoConfig.kOffSpeedFrameRateMin \
			else VideoConfig.kOffSpeedFrameRateMin[CameraModel.Unknown]
		frameRateMax = VideoConfig.kOffSpeedFrameRateMax[self.m_cameraState.cameraModel] \
			if self.m_cameraState.cameraModel in VideoConfig.kOffSpeedFrameRateMax \
			else VideoConfig.kOffSpeedFrameRateMax[CameraModel.Unknown]
		newOffSpeedFrameRate = self.m_cameraState.recordingFormatData.offSpeedFrameRate - 1
		
		if newOffSpeedFrameRate < frameRateMin:
			newOffSpeedFrameRate = frameRateMax

		self.onOffSpeedFrameRateChanged(newOffSpeedFrameRate)
		return newOffSpeedFrameRate

	def onOffSpeedFrameRateChanged(self, frameRate: fixedint.Int16):
		Logger.LogInfo("CameraControlInterface: onOffSpeedFrameRateChanged")								
		recordingFormatData = self.m_cameraState.recordingFormatData
		recordingFormatData.offSpeedFrameRate = frameRate
		self.m_usbPtpInterface.writeOffSpeedFrameRate(fixedint.UInt32(frameRate))

	# Iris
	def onApertureIncremented(self, currentApertureNormalised: float):
		Logger.LogInfo("CameraControlInterface: onApertureIncremented")								
		self.m_usbPtpInterface.incrementAperture(currentApertureNormalised)

	def onApertureDecremented(self, currentApertureNormalised: float):
		Logger.LogInfo("CameraControlInterface: onApertureDecremented")								
		self.m_usbPtpInterface.decrementAperture(currentApertureNormalised)

	def onApertureNormalisedChanged(self, apertureNormalised: float):
		Logger.LogInfo("CameraControlInterface: onApertureNormalisedChanged")								
		self.m_usbPtpInterface.writeApertureNormalised(apertureNormalised)

	def getApertureUnits(self) -> LensConfig.ApertureUnits:
		Logger.LogInfo("CameraControlInterface: getApertureUnits")								
		return self.m_cameraState.stopUnits

	# Shutter
	def onShutterIncremented(self) -> float:
		Logger.LogInfo("CameraControlInterface: onShutterIncremented")								
		nextShutterValue = self.getNextPresetShutterValue()
		self.onShutterChanged(nextShutterValue)
		return nextShutterValue

	def onShutterDecremented(self) -> float:
		Logger.LogInfo("CameraControlInterface: onShutterDecremented")								
		prevShutterValue = self.getPrevPresetShutterValue()
		self.onShutterChanged(prevShutterValue)
		return prevShutterValue

	def getNextPresetShutterValue(self) -> float:
		Logger.LogInfo("CameraControlInterface: getNextPresetShutterValue")								
		if (self.m_shutterValueIsAngle):
			for value in VideoConfig.kShutterAngles:
				if value > self.m_cameraState.shutterAngle:
					return value
			return VideoConfig.kShutterAngles[0]
		else:
			for value in VideoConfig.kShutterSpeeds:
				if value > self.m_cameraState.shutterSpeed:
					return float(value)
			return float(VideoConfig.kShutterSpeeds[0])

	def getPrevPresetShutterValue(self) -> float:
		Logger.LogInfo("CameraControlInterface: getPrevPresetShutterValue")								
		if self.m_shutterValueIsAngle:
			for value in VideoConfig.kShutterAngles.reverse():
				if value < self.m_cameraState.shutterAngle:
					return value
			return VideoConfig.kShutterAngles[-1:]
		else:
			for value in VideoConfig.kShutterSpeeds.reverse():
				if value < self.m_cameraState.shutterSpeed:
					return float(value)
			return float(VideoConfig.kShutterSpeeds[-1:])

	def onShutterChanged(self, shutterValue: float):
		Logger.LogInfo("CameraControlInterface: onShutterChanged")								
		if self.m_shutterValueIsAngle:
			shutterAngleX100 = fixedint.Int32(shutterValue * 100.0)
			self.m_usbPtpInterface.writeShutterAngle(fixedint.UInt16(shutterAngleX100))
		else:
			shutterSpeed = fixedint.Int32(shutterValue)
			self.m_usbPtpInterface.writeShutterSpeed(fixedint.UInt16(shutterSpeed))

	# ISO
	def onISOIncremented(self) -> fixedint.Int32:
		Logger.LogInfo("CameraControlInterface: onISOIncremented")								
		nextISOIndex = self.getNextISOIndex()
		self.onISOChanged(nextISOIndex)
		
		return nextISOIndex
	
	def onISODecremented(self) -> fixedint.Int32:
		Logger.LogInfo("CameraControlInterface: onISODecremented")								
		prevISOIndex = self.getPrevISOIndex()
		self.onISOChanged(prevISOIndex)
		
		return prevISOIndex
	
	def getNextISOIndex(self) -> fixedint.Int32:
		Logger.LogInfo("CameraControlInterface: getNextISOIndex")								
		isoValues = VideoConfig.kISOValues[CameraModel.Unknown]
		if self.m_cameraState.cameraModel in VideoConfig.kISOValues: 
			isoValues = VideoConfig.kISOValues[self.m_cameraState.cameraModel]
		try:
			newISOIndex = isoValues.index(self.m_cameraState.ISO) + 1
			if newISOIndex < len(isoValues.count): return newISOIndex
		except ValueError: pass

		return 0   
	
	def getPrevISOIndex(self) -> fixedint.Int32:
		Logger.LogInfo("CameraControlInterface: getPrevISOIndex")								
		isoValues = VideoConfig.kISOValues[CameraModel.Unknown]
		if self.m_cameraState.cameraModel in VideoConfig.kISOValues: 
			isoValues = VideoConfig.kISOValues[self.m_cameraState.cameraModel]
		try:
			newISOIndex = isoValues.index(self.m_cameraState.ISO) - 1
			if newISOIndex > 0: return newISOIndex
		except ValueError: pass

		return len(isoValues) - 1   

	def onSensorGainChanged(self, isoIndex: fixedint.Int32):
		Logger.LogInfo("CameraControlInterface: onSensorGainChanged")								
		isoValues = VideoConfig.kISOValues[CameraModel.Unknown]
		if self.m_cameraState.cameraModel in VideoConfig.kISOValues:
			isoValues = VideoConfig.kISOValues[self.m_cameraState.cameraModel]
		iso = isoValues[isoIndex]
		self.m_usbPtpInterface.writeExposureIndex(fixedint.UInt16(iso))
	
	def onISOChanged(self, isoIndex: fixedint.Int32):
		Logger.LogInfo("CameraControlInterface: onISOChanged")								
		isoIndex = fixedint.Int32(isoIndex)
		isoValues = VideoConfig.kISOValues[CameraModel.Unknown]
		if self.m_cameraState.cameraModel in VideoConfig.kISOValues:
			isoValues = VideoConfig.kISOValues[self.m_cameraState.cameraModel]
		iso = isoValues[isoIndex]
		self.m_usbPtpInterface.writeExposureIndex(fixedint.UInt16(iso))
	
	def onNDFilterStopChanged(self, stop: float, displayMode: VideoConfig.NDFilterDisplayMode):
		Logger.LogInfo("CameraControlInterface: onNDFilterStopChanged")								
		self.m_usbPtpInterface.writeNDFilter(CCUPacketTypes.CCUFixedFromfloat(stop))
	
	def onFocusPositionReceived(self, focusPositionInt: fixedint.Int32):
		# Convert lerp to 0 - 1
		focusPosition = float(focusPositionInt / 65535)
		Logger.LogInfo("CameraControlInterface: onFocusPositionReceived float={} int={}".format(focusPosition, focusPositionInt))
		self.m_focusSetEvent.set()

	def onFocusPullSet(self, focusPullStep: fixedint.Int32):
		Logger.LogInfo("CameraControlInterface: onFocusPullSet")								

		# Make focus pull value range from 0 - 1
		if focusPullStep < 0: focusPullStep = 0
		if focusPullStep > 1: focusPullStep = 1
		focusDistanceLerped = fixedint.Int32(focusPullStep * 65535) 

		# focusDistanceLerped = fixedint.Int32(float(focusPullStep + 100) / 200 * 65535)
		# if focusDistanceLerped < 100: focusDistanceLerped = 100 # cap to not hit the edges
		# if focusDistanceLerped > 65435: focusDistanceLerped = 65435 # cap to not hit the edges
		
		self.m_usbPtpInterface.writeFocusPosition(focusDistanceLerped)
		Logger.LogInfo("CameraControlInterface: onFocusPullChanged finished")								

	def onFocusPullSetInt(self, focusDistance: fixedint.Int32):
		Logger.LogInfo("CameraControlInterface: onFocusPullSetInt")										
		self.m_focusSetEvent.clear()
		self.m_usbPtpInterface.writeFocusPosition(fixedint.Int32(focusDistance))
		Logger.LogInfo("CameraControlInterface: onFocusPullSetInt - waiting for event to reflect change")										
		return self.m_focusSetEvent.wait(2)
		# Logger.LogInfo("CameraControlInterface: onFocusPullSetInt finished")								

	def onTransportInfoReceived(self, info: TransportInfo):
		Logger.LogInfo("CameraControlInterface: onTransportInfoReceived")								
		self.m_cameraState.updateTransportInfo(info)
			
	def onRecordTimeRemainingReceived(self, remainingRecordTimes: List[str], remainingTimesInMinutes: List[fixedint.Int16]):
		Logger.LogWithInfo("onRecordTimeRemainingReceived {} {}".format(remainingRecordTimes, remainingTimesInMinutes))
		self.cachedSlotData['recordTimeRemaining'] = (remainingRecordTimes, remainingTimesInMinutes)
		slotCount = min(len(self.m_cameraState.slots), min(len(remainingRecordTimes), len(remainingTimesInMinutes)))
		for slotIndex in range(slotCount):
			self.m_cameraState.slots[slotIndex].remainingRecordTime = remainingRecordTimes[slotIndex]
			self.m_cameraState.slots[slotIndex].remainingTimeInMinutes = remainingTimesInMinutes[slotIndex]

	kLowSeverityThresholdMinutes = 5
	kHighSeverityThresholdMinutes = 3

	# OutgoingRecordingControlFromUIDelegate methods
	def onRecordPressed(self):
		Logger.LogInfo("CameraControlInterface: onRecordPressed")								
		isCurrentlyInPreview = (self.m_cameraState.transportInfo.transportMode == CCUPacketTypes.MediaTransportMode.Preview)
		if self.m_usbPtpInterface is not None:
			if isCurrentlyInPreview:
				self.m_usbPtpInterface.startRecord()
			else:
				self.m_usbPtpInterface.stopRecord()

	def onStillCapturePressed(self):
		Logger.LogInfo("CameraControlInterface: onStillCapturePressed")								
		self.m_usbPtpInterface.stillCapture()
	