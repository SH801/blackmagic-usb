# -LICENSE-START-
# Copyright (c) 2020 Blackmagic Design
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# -LICENSE-END-
# 


import fixedint
from typing import List
from Types import *
from LogFunctions import *
from UtilityFunctions import *
from MemoryLayout import *
from PTPTypes import *
from PTPErrorCodes import *

PTPStringLengthSize = fixedint.UInt8
PTPArrayLengthSize = fixedint.UInt32
PTPDataArrayLengthSize = fixedint.UInt16

class PTPDeserialiser:

	def __init__(self, payload):
		# Shallow copy
		self.m_payload 				= payload
		self.m_payloadLength 		= len(payload)
		self.m_bytesDeserialised 	= 0

	# elemSize allows deserialising to an enum with a specific base type
	# def deserialiseByElementOrSize(self, elementPrototype, elemSize = 0):
	# 	nextSizeInBytes = elemSize
	# 	if elemSize == 0: nextSizeInBytes = MemoryLayout.size(elementPrototype)
	# 	if (self.m_payloadLength - self.m_bytesDeserialised) < nextSizeInBytes:
	# 		raise PTPDecodingError.PacketDeserialisingFailed

	# 	ret = bytearray()
	# 	ret[:] = self.m_payload[self.m_bytesDeserialised:(self.m_bytesDeserialised + nextSizeInBytes)]
	# 	self.m_bytesDeserialised += nextSizeInBytes
	# 	return UtilityFunctions.FromByteArray(ret)

	def deserialiseBySize(self, elemSize: fixedint.Int32):
		nextSizeInBytes = elemSize
		if (self.m_payloadLength - self.m_bytesDeserialised) < nextSizeInBytes:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)

		ret = bytearray()
		ret[:] = self.m_payload[self.m_bytesDeserialised:(self.m_bytesDeserialised + nextSizeInBytes)]
		self.m_bytesDeserialised += nextSizeInBytes
		return UtilityFunctions.FromByteArray(ret)

	def deserialiseBySizeKeepByteArray(self, elemSize: fixedint.Int32):
		nextSizeInBytes = elemSize
		if (self.m_payloadLength - self.m_bytesDeserialised) < nextSizeInBytes:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)

		ret = bytearray()
		ret[:] = self.m_payload[self.m_bytesDeserialised:(self.m_bytesDeserialised + nextSizeInBytes)]
		self.m_bytesDeserialised += nextSizeInBytes
		return ret

	def deserialiseDataArrayBySize(self, elemSize: fixedint.Int32):
		arrayLength = PTPDataArrayLengthSize(0)
		try:
			arrayLength = PTPDataArrayLengthSize(self.deserialiseBySize(MemoryLayout.size(arrayLength)))
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)

		# Skip past redundant 0
		self.deserialiseBySize(elemSize)
		# arrayLength += 2 # first two values of array are count and 0		
		bytesRequired = fixedint.Int32(arrayLength * elemSize)

		if (self.m_payloadLength - self.m_bytesDeserialised) < bytesRequired:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)

		retArray = []
		while (arrayLength > 0):
			try:
				retArray.append(self.deserialiseBySize(elemSize))
			except:
				raise Exception(PTPDecodingError.PacketDeserialisingFailed)
			arrayLength -= 1

		return retArray
	
	def deserialiseDataArray(self):
		arrayLength = PTPDataArrayLengthSize(0)
		try:
			arrayLength = PTPDataArrayLengthSize(self.deserialiseBySize(MemoryLayout.size(arrayLength)))
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)

		retArray = []
		while (arrayLength > 0):
			try:
				retArray.append(str(self.deserialiseString()))
			except:
				raise Exception(PTPDecodingError.PacketDeserialisingFailed)
			arrayLength -= 1

		return retArray
	
	def deserialiseString(self):
		stringLength = PTPStringLengthSize(0)
		try:
			stringLength = PTPStringLengthSize(self.deserialiseBySize(MemoryLayout.size(stringLength)))
		except:
			Logger.LogError("PTPDecodingError.PacketDeserialisingFailed")
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)

		nextSizeInBytes = fixedint.Int32(stringLength * 2)
		if (self.m_payloadLength - self.m_bytesDeserialised) < nextSizeInBytes:
			Logger.LogError("PTPDecodingError.PacketDeserialisingFailed")
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)

		data = self.m_payload[self.m_bytesDeserialised:(self.m_bytesDeserialised + nextSizeInBytes)]
		self.m_bytesDeserialised += nextSizeInBytes
		try:
			ret = bytes(data).decode(encoding="utf8")
			return ret
		except:
			Logger.LogError("PTPDecodingError.PacketDeserialisingFailed UTF decode failed")
			return None

	# elemSize allows deserialising to an enum with a specific base type
	def deserialise(self, buffer, obj, elemSize: fixedint.Int32):
			
		if (obj.__bases__ is not None) & (obj.__bases__[1] == BaseEnum):
			Logger.LogError("Deserialiser does not support deserialising enums.")
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
		
		arrayLength = PTPArrayLengthSize(0)
		try:
			arrayLength = PTPArrayLengthSize(self.deserialiseBySize(MemoryLayout.size(arrayLength)))
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
		
		bytesRequired = fixedint.Int32(arrayLength * elemSize)
		if (self.m_payloadLength - self.m_bytesDeserialised) < bytesRequired:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
		
		while arrayLength > 0:
			try:
				buffer.append(self.deserialiseByElementOrSize(obj, elemSize))
			except:
				raise Exception(PTPDecodingError.PacketDeserialisingFailed)
			arrayLength -= 1
		return buffer
	
	def deserialiseOperationCode(self):
		raw = OperationCodeType(OperationCode.Undefined.value)
		try:
			raw = OperationCodeType(self.deserialiseBySize(MemoryLayout_OperationCodeType__size))
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
		if raw not in OperationCode: return OperationCode.Undefined
		return OperationCode(raw)
	
	def deserialiseEventCode(self):
		raw = EventCodeType(EventCode.Undefined.value)
		try:
			raw = EventCodeType(self.deserialiseBySize(MemoryLayout_EventCodeType__size))
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
		if raw not in EventCode: return EventCode.Undefined
		return EventCode(raw)
	
	def deserialiseDevicePropCode(self):
		raw = DevicePropCodeType(DevicePropCode.Undefined.value)
		try:
			raw = DevicePropCodeType(self.deserialiseBySize(MemoryLayout_DevicePropCodeType__size))
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
		if raw not in DevicePropCode: return DevicePropCode.Undefined
		return DevicePropCode(raw)
	
	def deserialiseDataTypeCode(self):
		raw = DataTypeCodeType(DataTypeCode.Undefined.value)
		try:
			raw = DataTypeCodeType(self.deserialiseBySize(MemoryLayout_DataTypeCodeType__size))
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
		if raw not in DataTypeCode: return DataTypeCode.Undefined
		return DataTypeCode(raw)

	def deserialiseDevicePropPermissions(self):
		raw = DevicePropPermissionsType(DevicePropPermissions.ReadOnly.value)
		try:
			raw = DevicePropPermissionsType(self.deserialiseBySize(MemoryLayout_DevicePropPermissionsType__size))
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
		if raw not in DevicePropPermissions: return DevicePropPermissions.ReadOnly
		return DevicePropPermissions(raw)

	def deserialiseDevicePropForm(self):
		raw = DevicePropFormType(DevicePropForm.NONE.value)
		try:
			raw = DevicePropFormType(self.deserialiseBySize(MemoryLayout_DevicePropFormType__size))
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
		if raw not in DevicePropForm: return DevicePropForm.NONE
		return DevicePropForm(raw)

	def deserialise(self, element):
		elementType = Types.getType(element)
		if elementType['isList']: 
			return self.deserialiseList(elementType['type'])
		else: 
			match elementType['type']:
				case 'OperationCode':			return self.deserialiseOperationCode()
				case 'EventCode':				return self.deserialiseEventCode()
				case 'DevicePropCode':			return self.deserialiseDevicePropCode()
				case 'DataTypeCode':			return self.deserialiseDataTypeCode()
				case 'DevicePropPermissions':	return self.deserialiseDevicePropPermissions()
				case 'DevicePropForm': 			return self.deserialiseDevicePropForm()
				case 'str':						return self.deserialiseString()
				case _:
					size = MemoryLayout.sizeTypeString(elementType['type'])
					if size is None:
						Logger.LogError("No size found for type {}".format(elementType['type']))
						return None
					else:
						return self.deserialiseBySize(size)

	# Array deserialisations

	def deserialiseList(self, elementtype):
		match elementtype:
			case 'UInt8': 			return self.deserialiseListUInt8()
			case 'UInt16': 			return self.deserialiseListUInt16()
			case 'UInt32': 			return self.deserialiseListUInt32()
			case 'OperationCode':	return self.deserialiseListOperationCode()
			case 'EventCode':		return self.deserialiseListEventCode()
			case 'DevicePropCode':	return self.deserialiseListDevicePropCode()
			case _: 				
				Logger.LogError("No deserialise for type {}".format(elementtype))
				return None

	def deserialiseListBySize(self, size):
		try:
			return self.deserialiseDataArrayBySize(size)
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)

	def deserialiseListUInt8(self):
		return self.deserialiseListBySize(MemoryLayout_UInt8__size)

	def deserialiseListUInt16(self):
		return self.deserialiseListBySize(MemoryLayout_UInt16__size)

	def deserialiseListUInt32(self):
		return self.deserialiseListBySize(MemoryLayout_UInt32__size)

	def deserialiseListOperationCode(self):
		try:
			temp = self.deserialiseListBySize(MemoryLayout_OperationCodeType__size)
			buffer = []
			for item in temp:
				if item in OperationCode:	buffer.append(OperationCode(item))
				else:						buffer.append(OperationCode.Undefined)
			return buffer
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
	
	def deserialiseListEventCode(self):
		try:
			temp = self.deserialiseListBySize(MemoryLayout.sizeTypeString('EventCode'))
			buffer = []
			for item in temp:
				if item in EventCode:		buffer.append(EventCode(item))
				else:						buffer.append(EventCode.Undefined)
			return buffer
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
	
	def deserialiseListDevicePropCode(self):
		try:
			temp = self.deserialiseListBySize(MemoryLayout.sizeTypeString('DevicePropCode'))
			buffer = []
			for item in temp:
				if item in DevicePropCode:	buffer.append(DevicePropCode(item))
				else:						buffer.append(DevicePropCode.Undefined)
			return buffer
		except:
			raise Exception(PTPDecodingError.PacketDeserialisingFailed)
