# -LICENSE-START-
# Copyright (c) 2020 Blackmagic Design
# 
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
# 
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# -LICENSE-END-
#

import fixedint
import inspect
import asyncio
from threading import Semaphore
from queue import Queue, Empty as QueueEmpty
from StoppableThread import *
from CustomQueue import *
from LogFunctions import *
from PTPTypes import *
from PTPContainer import *
from PTPDeviceInfo import *
from PTPPacketDecoder import *
from PTPPacketEncoder import *
from USBBulkDevice import *
from LensConfig import *


class SerialThread(StoppableThread):

	def __init__(self,  *args, **kwargs):
		super().__init__(*args, **kwargs)
		self.lastResult = None

	def setParameters(self, queue):
		self.task_queue = queue
	
	def run(self):
		Logger.ThreadLogWithInfo("SerialThread: started")
		
		while not self.stopped():
			Logger.LogWithInfo("SerialThread: waiting for queue item")
			try:
				functionAndParameters = self.task_queue.get(timeout=1)
				# functionAndParameters = self.task_queue.get()
				Logger.LogWithInfo("SerialThread: received queue item function: {}".format(functionAndParameters['function'].__name__))
				try:
					self.lastResult = functionAndParameters['function'](*functionAndParameters['parameters'])
				finally:
					Logger.LogWithInfo("SerialThread: function completed/failed, indicate task_done")
					self.task_queue.task_done()
			except QueueEmpty:
				pass

		Logger.ThreadLogWithInfo("SerialThread: stopped")

class EventReadThread(StoppableThread):

	def __init__(self,  *args, **kwargs):
		super().__init__(*args, **kwargs)

	def setParameters(self, queue, delegate):
		self.delegate = delegate
		self.task_queue = queue
	
	def run(self):
		Logger.ThreadLogWithInfo("EventReadThread: started")
		while not self.stopped():
			Logger.LogWithInfo("EventReadThread: waiting for queue item")
			try:
				self.task_queue.get(timeout=1)
				# self.task_queue.get()
				Logger.LogWithInfo("EventReadThread: received queue item")
				try:
					self.delegate.performRead()
				finally:
					Logger.LogWithInfo("EventReadThread: function completed/failed, indicate task_done")
					self.task_queue.task_done()
			except QueueEmpty:
				pass

		Logger.ThreadLogWithInfo("EventReadThread: stopped")

class USBPTPController:

	# Responses are asynchronous
	class PTPTransaction:

		def __init__(self, transactionId, operationCode, responseCode, dataContainer):
			self.transactionId 	= TransactionID(transactionId)
			self.operationCode 	= operationCode
			self.responseCode 	= responseCode
			self.dataContainer 	= dataContainer

	def __init__(self, device: USBBulkDevice):
		self.m_usbPtpDevice 								= device
		self.m_packetReceivedDelegate 						= PTPPacketDecoderDelegate()
		self.m_isSessionOpened 								= False
		self.m_sessionId 									= fixedint.UInt8(1)
		self.m_transactionId 								= TransactionID(1)
		self.m_commandContainer:Container 					= Container()
		self.m_eventBuffer 									= bytearray(PTPTypes.kMaxPacketSize)
		self.m_deviceInfo:PTPDeviceInfo
		self.m_deviceDescs 									= []
		self.m_recordStartedTransactionId:TransactionID 	= PTPTypes.kInvalidCaptureTransactionId
		# PTP packet handlers
		self.m_ptpEncoder 									= PTPPacketEncoder()
		self.m_ptpEncoder.setDelegate(self)

		# Threads
		self.m_semaphore 									= Semaphore()
		self.m_transactionQueue 							= CustomQueue()
		self.m_serialQueue 									= Queue()
		self.m_serialThread 								= SerialThread(name="SerialThread")
		self.m_serialThread.setParameters(queue=self.m_serialQueue)

		self.m_DispatchQueue 								= self.m_serialQueue
		self.m_eventReadQueue 								= Queue()
		self.m_eventReadThread 								= EventReadThread(name="EventReadThread")
		self.m_eventReadThread.setParameters(queue=self.m_eventReadQueue, delegate=self)

		# Start threads and reading

		self.start()

	def start(self):
		if self.m_serialThread: self.m_serialThread.start()
		if self.m_eventReadThread: self.m_eventReadThread.start()
		self.startReadEvent()

	def stop(self):
		if self.m_serialThread is not None:
			Logger.ThreadLogWithInfo("shutdown - stopping serialWorker")
			self.m_serialThread.stop()
			self.m_serialThread.join()
			self.m_serialThread = None
			Logger.ThreadLogWithInfo("shutdown - serialWorker stopped")

		if self.m_eventReadThread is not None:
			Logger.ThreadLogWithInfo("shutdown - stopping readWorker")
			self.m_eventReadThread.stop()
			self.m_eventReadThread.join()
			self.m_eventReadThread = None
			Logger.ThreadLogWithInfo("shutdown - readWorker stopped")

	def __del__(self):
		self.stop()
		
	def getDevice(self) -> USBBulkDevice:
		return self.m_usbPtpDevice
    
	def isSessionOpened(self) -> bool:
		return self.m_isSessionOpened

	def startReadEvent(self):
		Logger.LogWithInfo("startReadEvent")
		self.m_eventReadQueue.put_nowait(self.performRead)

	def performRead(self):
		# Note: Blocks while waiting for events to come through the interrupt pipe
		self.m_eventBuffer = self.m_usbPtpDevice.readInterruptPipe(PTPTypes.kMaxPacketSize)
		if self.m_eventBuffer is False:
			Logger.LogWarning("Invalid PTP packet read")
			return
		
		bytesRead = len(self.m_eventBuffer)
		if bytesRead >= PTPTypes.kContainerHeaderSize:
			# Intercept events so that the controller can start a transaction to
			# 'get' the actual value for the event that was raised before sending
			# the value to the registered delegate.
			PTPPacketDecoder.DecodePacket(self.m_eventBuffer, self)
			
			# Start next read event as soon as we finish handling the last read event.
			self.startReadEvent()
		
		else:
			Logger.LogWarning("Invalid PTP packet read")

	def setPacketDecodedDelegate(self, delegate: PTPPacketDecoderDelegate):
		self.m_packetReceivedDelegate = delegate

	def readFromUSBDevice(self) -> bool:
		# Kick off a read on the PTP device
		buffer = self.m_usbPtpDevice.readPipe(PTPTypes.kMaxPacketSize)		
		if buffer is False:
			Logger.LogError("Invalid PTP packet read")
			# Optionally set pipe stall?
			return False
		
		Logger.Log("readFromUSBDevice: Buffer size {}".format(len(buffer)))
		if len(buffer) >= PTPTypes.kContainerHeaderSize:
			# Intercept responses instead of responding to a registered delegate
			# since the response (OK or failed) is not useful outside of the protocol.
			buffer = PTPPacketDecoder.DecodePacket(buffer, self)
			return True

	# PTPPacketEncoderDelegate: Sending packet functions
	def onPTPPacketEncoded(self, commandContainer: Container, dataContainer: Container) -> bool:

		if self.m_usbPtpDevice is None:
			Logger.LogError("Cannot send command because we do not have a valid USB PTP device.")
			return False
		
		# First send the command container
		if self.m_usbPtpDevice.writePipe(commandContainer.serializeContainerDataToByteArray()) is False:
			Logger.LogError("Failed to write command to USB device. Transaction aborted")
			return False

		# Then send the data container if non-None
		if dataContainer is not None:
			if (self.m_usbPtpDevice.writePipe((dataContainer.serializeContainerDataToByteArray())) == False):
				Logger.LogError("Failed to write data to USB device. Transaction aborted")
				return False

		operationCode = OperationCode.Undefined
		if commandContainer.m_containerData.code in OperationCode: operationCode = OperationCode(commandContainer.m_containerData.code)
		Logger.LogWithInfo("{} Encoded Operation: {} for Transaction {}".format(inspect.stack()[1].function, hex(OperationCodeType(operationCode.value)), self.m_transactionId))

		self.m_serialQueue.put({	'function': 	self.m_transactionQueue.enqueue, 
									'parameters': 	(USBPTPController.PTPTransaction(self.m_transactionId, operationCode, ResponseCode.Undefined, None),)})

		Logger.LogWithInfo("onPTPPacketEncoded - send request to m_serialQueue")
		# Transaction ID is incremented for every packet sent regardless of success/failure
		self.m_transactionId += 1
		
		return self.readFromUSBDevice()
	
	def responseReceived(self, parameters):
		maxDequeueAllowed = self.m_transactionQueue.count()
		while (maxDequeueAllowed > 0):
			# Get the first queued transaction
			queuedTransactionId = self.m_transactionQueue.get(0).transactionId
			if queuedTransactionId == parameters['transactionId']:
				self.m_transactionQueue.setResponseCodeForIndexTransactionId(0, parameters['transactionId'], parameters['responseCode'])					
				break
			elif queuedTransactionId > parameters['transactionId']:
				Logger.LogError("Ignoring response for a past transaction. ID: {}".format(queuedTransactionId))
				break
			elif queuedTransactionId < parameters['transactionId']:
				Logger.LogError("Discarding PTP transaction ID: {} due to receiving response for a later transaction ID: {}".format(queuedTransactionId, parameters['transactionId']))
				self.m_transactionQueue.dequeue()	# discard
			
			maxDequeueAllowed -= 1

	# PTPPacketDecoderDelegate
	def onResponseReceived(self, transactionId: TransactionID, responseCode: ResponseCode):
		# We only need to interact with the first transaction in the queue since we must receive a response for every request sequentially.
		# The PTP standard dictates that there can only be one transaction at a time that can take place within a session.
		# Raise an error if we detect transaction out of order, and dequeue it immediately.

		self.m_serialQueue.put_nowait({	'function': 	self.responseReceived, 
										'parameters': 	({'transactionId': transactionId, 'responseCode': responseCode},) } )
			
		Logger.LogWithInfo("{} signaling now".format(inspect.stack()[1].function))
		# Python's asyncio.Semaphore.release() increments counter like Swift's semaphore.signal()
		self.m_semaphore.release()
	
	def dataReceived(self, dataContainer: Container):
		queueLength = self.m_transactionQueue.count()
		for i in range(queueLength):
			queuedTransactionId = self.m_transactionQueue.get(0).transactionId
			if queuedTransactionId == dataContainer.m_containerData.transactionId:
				self.m_transactionQueue.setDataContainerForIndex(i, dataContainer)
				break

	def onDataReceived(self, dataContainer: Container):
		# Similar to onResponseReceived, data phase cannot occur without a command first requesting for data.
		# But don't discard any transactions here since data phase is optional and may not happen for every transaction.
		# Allow onResponseReceived to perform the check and discard.

		self.m_serialQueue.put({	'function': 	self.dataReceived, 
										'parameters': 	(dataContainer,) })
		
		# Kick off a read on the PTP device for the response since we just received the optional data phase container
		self.readFromUSBDevice()

	def onDevicePropertyChanged(self, devicePropCode: DevicePropCode):
		Logger.Log("{} {}".format(inspect.stack()[1].function, devicePropCode))
		match devicePropCode:
			case DevicePropCode.FNumber:				self.readApertureFNumber()
			case DevicePropCode.ExposureIndex:			self.readExposureIndex()
			case DevicePropCode.BMD_ShutterAngle:		self.readShutterAngle()
			case DevicePropCode.BMD_WhiteBalanceKelvin:	self.readWhiteBalance()
			case DevicePropCode.BMD_WhiteBalanceTint:   self.readTint()
			case DevicePropCode.BMD_FrameRate:			self.readFrameRate()
			case DevicePropCode.BMD_OffSpeedFrameRate:	self.readOffSpeedFrameRate()
			case DevicePropCode.BMD_OffSpeedEnabled:	self.readOffSpeedEnabled()
			case DevicePropCode.BMD_RecordingState:		self.readRecordingState()
			case DevicePropCode.BMD_NDFilter:			self.readNDFilter()
			case DevicePropCode.BMD_FocusPosition:		self.readFocusPosition()
			case _:										pass	

	def onDeviceInfoReceived(self, deviceInfo: PTPDeviceInfo): 									pass
	def onExposureReceived(self, exposure: fixedint.Int32): 									pass
	def onGainReceived(self, sensorGain: fixedint.Int32):			 							pass
	def onRecordTimeRemainingReceived(	self, \
				   						remainingRecordTimes: List[str], \
										remainingRecordTimesInMinutes: List[fixedint.Int16]): 	pass
	def onBatteryLevelReceived(self, percentage: fixedint.UInt8): 								pass	   
	def onRecordingResolutionReceived(self, width: fixedint.Int16, height: fixedint.Int16): 	pass
	def onApertureFstopReceived(self, fstop: float, stopUnits: LensConfig.ApertureUnits): 		pass
	def onApertureNormalisedReceived(self, normalisedAperture: float): 							pass
	def onFocalLengthReceived(self, focalLength: fixedint.UInt32): 								pass
	def onFocusDistanceReceived(self, focusDistance: fixedint.Int16): 							pass
	def onISOReceived(self, iso: fixedint.Int32):			 									pass
	def onShutterSpeedReceived(self, shutterSpeed: fixedint.Int32): 							pass
	def onShutterAngleReceived(self, shutterAngleX100: fixedint.Int32): 						pass
	def onFocusPositionReceived(self, focusPosition: fixedint.Int32): 							pass
	def onWhiteBalanceKelvinReceived(self, whiteBalance: fixedint.Int16): 						pass
	def onWhiteBalanceTintReceived(self, tint: fixedint.Int16): 								pass
	def onFrameRateReceived(self, frameRate: fixedint.Int32): 									pass
	def onOffSpeedFrameRateReceived(self, offSpeedFrameRate: fixedint.Int32): 					pass
	def onOffSpeedEnabledReceived(self, enabled: bool): 										pass
	def onZoomPositionReceived(self, zoomPosition: fixedint.Int32): 							pass
	def onNDFilterReceived(self, stops: float): 												pass
	def onRecordingStarted(self): 																pass
	def onRecordingStopped(self): 																pass
       
	def onDevicePropertyDescriptionChanged(self, devicePropCode: DevicePropCode):
		Logger.Log(inspect.stack()[1].function)
		self.getDevicePropDesc(devicePropCode)
	
	def onDevicePropDescReceived(self, devicePropDesc: PTPDevicePropDesc):
		self.m_deviceDescs = list(filter(lambda x: (x.m_devicePropCode != devicePropDesc.m_devicePropCode), self.m_deviceDescs))
		self.m_deviceDescs.append(devicePropDesc)
	
	def waitForResponse(self) -> PTPTransaction:
		Logger.Log(inspect.stack()[1].function)
		# Python's Semaphore operates in opposite way to Swift's 
		# in that acquire decrements counter and release increments counter
		Logger.Log("Waiting for semaphore acquire")
		if not self.m_semaphore.acquire(timeout=0.5):
			Logger.Log("{} return None (timeout on semaphore.acquire)".format(inspect.stack()[1].function))
			return self.PTPTransaction(0, ResponseCode.GeneralError, None, None)
		Logger.Log("Semaphore acquired")
		
		self.m_serialQueue.put({	'function': 	self.m_transactionQueue.dequeue, 
									'parameters': 	() } )		
		self.m_serialQueue.join()
		if self.m_serialThread.lastResult is None:
			return self.PTPTransaction(0, ResponseCode.GeneralError, None, None)

		return self.m_serialThread.lastResult				
	
	def openSessionWithforceClosePreviousSessionIfPresent(self, forceClosePreviousSessionIfPresent: bool) -> bool:
		Logger.Log("openSessionWithforceClosePreviousSessionIfPresent")
		openSessionSuccessful = self.openSession()
		if (openSessionSuccessful is False) & forceClosePreviousSessionIfPresent:
			self.closeSession()
			return self.openSession()				
		return openSessionSuccessful

	def openSession(self) -> bool:
		# Logger.Log(inspect.stack()[1].function)
		Logger.Log("openSession")

		if self.m_ptpEncoder.encodeOpenSessionCommand(self.m_transactionId, self.m_sessionId):
			ptpTransaction = self.waitForResponse()
			if ptpTransaction is not None:
				if ptpTransaction.responseCode == ResponseCode.OK:
					self.m_sessionId += 1
					self.m_isSessionOpened = True
					
					# For update of all device info and supported operations, events and device prop codes
					self.getDeviceInfo()
					return True

		Logger.LogError("Failed to open session")
		return False
	
	def closeSession(self) -> bool:
		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeCloseSessionCommand(self.m_transactionId):
			ptpTransaction = self.waitForResponse()
			if ptpTransaction is not None:
				if ptpTransaction.responseCode == ResponseCode.OK:
					self.m_isSessionOpened = False
					return True
					
		Logger.LogError("Failed to close session")
		return False
	
	def getDeviceInfo(self) -> bool:
		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeGetDeviceInfoCommand(self.m_transactionId) is False: return False 

		ptpTransaction = self.waitForResponse()
		if ptpTransaction is None: return False
		if ptpTransaction.responseCode != ResponseCode.OK: return False 
		if ptpTransaction.dataContainer is None: return False 
		
		# Deserialise device info
		payloadDecodedDelegate = self.m_packetReceivedDelegate
		dataContainer = ptpTransaction.dataContainer
		if (payloadDecodedDelegate is not None) & (dataContainer is not None):
			self.m_deviceInfo = PTPPacketDecoder.DecodePayloadAsDeviceInfo(dataContainer, payloadDecodedDelegate, self.m_DispatchQueue)
			
			# Ensure we get the latest value of each supported device prop code and fire the value to the delegate
			# for devicePropCode in self.m_deviceInfo.m_supportedDevicePropCode:
			# 	self.getDevicePropValue(devicePropCode)
			# 	self.getDevicePropDesc(devicePropCode)
							
			return True
		
		return False
	
	def getDevicePropDesc(self, devicePropCode: DevicePropCode) -> bool:
		Logger.Log("{}, {}".format(inspect.stack()[1].function, DevicePropCodeType(devicePropCode.value)))	     
		if self.m_ptpEncoder.encodeGetDevicePropDescCommand(self.m_transactionId, devicePropCode) is False: return False 

		ptpTransaction = self.waitForResponse()
		if ptpTransaction.responseCode != ResponseCode.OK: return False 
		if ptpTransaction.dataContainer is None: return False 
		
		dataContainer = ptpTransaction.dataContainer
		# Let self keep a copy for now.
		PTPPacketDecoder.DecodePayloadAsDevicePropDesc(dataContainer, self, self.m_DispatchQueue)
		
		# Deserialise device prop desc
		payloadDecodedDelegate = self.m_packetReceivedDelegate
		dataContainer = ptpTransaction.dataContainer
		if (payloadDecodedDelegate is not None) & (dataContainer is not None):
			PTPPacketDecoder.DecodePayloadAsDevicePropDesc(dataContainer, payloadDecodedDelegate, self.m_DispatchQueue)
			return True		
		
		return False
	
	def stillCapture(self) -> bool:
		if self.m_isSessionOpened is False: return False
				
		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeStillCaptureCommand(self.m_transactionId):
			return self.waitForResponse().responseCode == ResponseCode.OK
		
		return False
	
	def startRecord(self) -> bool:
		if self.m_isSessionOpened is False: return False		
		
		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeStartRecordCommand(self.m_transactionId):
			ptpTransaction = self.waitForResponse()
			if ptpTransaction.responseCode != ResponseCode.OK: return False
			self.m_recordStartedTransactionId = PTPTypes.kInvalidCaptureTransactionId
			if (ptpTransaction.dataContainer is not None) & (ptpTransaction.dataContainer.m_containerData is not None):
				self.m_recordStartedTransactionId = ptpTransaction.dataContainer.m_containerData.transactionId					

		return False
	
	def stopRecord(self) -> bool:
		if self.m_isSessionOpened is False: return False

		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeStopRecordCommand(self.m_transactionId, self.m_recordStartedTransactionId):
			return self.waitForResponse().responseCode == ResponseCode.OK
		
		return False
	
	def changeFocus(self, nearer: bool, steps: fixedint.UInt32) -> bool:
		if self.m_isSessionOpened is False: return False
		
		Logger.Log("{} nearer = {}, steps = {}".format(inspect.stack()[1].function, nearer, steps))
		if self.m_ptpEncoder.encodeChangeFocusCommand(self.m_transactionId, nearer, steps):
			return self.waitForResponse().responseCode == ResponseCode.OK

		return False
	
	def autoFocus(self, xPosRatio: float = 0, yPosRatio: float = 0) -> bool:
		if self.m_isSessionOpened is False: return False
	
		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeAutoFocusCommand(self.m_transactionId, xPosRatio, yPosRatio):
			return self.waitForResponse().responseCode == ResponseCode.OK
		
		return False
	
	def cancelAutoFocus(self, xPosRatio: float = 0, yPosRatio: float = 0) -> bool:
		if self.m_isSessionOpened is False: return False
		
		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeCancelAutoFocusCommand(self.m_transactionId):
			return self.waitForResponse().responseCode == ResponseCode.OK

		return False
	
	def enableAutoExposure(self) -> bool:
		if self.m_isSessionOpened is False: return False
		
		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeEnableAutoExposureCommand(self.m_transactionId):
			return self.waitForResponse().responseCode == ResponseCode.OK
		
		return False
	
	def disableAutoExposure(self) -> bool:
		if self.m_isSessionOpened is False: return False
		
		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeDisableAutoExposureCommand(self.m_transactionId):
			return self.waitForResponse().responseCode == ResponseCode.OK

		return False
	
	def enableAutoWhiteBalance(self) -> bool:
		if self.m_isSessionOpened is False: return False
				
		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeEnableAutoWhiteBalanceCommand(self.m_transactionId):
			return self.waitForResponse().responseCode == ResponseCode.OK
		
		return False
	
	def disableAutoWhiteBalance(self) -> bool:
		if self.m_isSessionOpened is False: return False	
		
		Logger.Log(inspect.stack()[1].function)
		if self.m_ptpEncoder.encodeDisableAutoWhiteBalanceCommand(self.m_transactionId):
			return self.waitForResponse().responseCode == ResponseCode.OK

		return False
	
	def getDevicePropValue(self, devicePropCode: DevicePropCode) -> bool:
		if self.m_isSessionOpened is False: return False
		
		Logger.Log("{} Device Prop Code: {}".format(inspect.stack()[1].function, devicePropCode))
		self.m_ptpEncoder.encodeGetDevicePropValueCommand(self.m_transactionId, devicePropCode)
		ptpTransaction = self.waitForResponse()
		if ptpTransaction.responseCode != ResponseCode.OK: return False
		dataContainer = ptpTransaction.dataContainer
		if dataContainer is None: return False
		payloadDecodedDelegate = self.m_packetReceivedDelegate
		if payloadDecodedDelegate is None: return False

		PTPPacketDecoder.DecodePayloadAsDevicePropValue(	dataContainer, \
						  									devicePropCode, \
															payloadDecodedDelegate, \
															self.m_deviceDescs, \
															self.m_DispatchQueue)

		return True
				
	def readBatteryLevel(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.BatteryLevel)
	def readImageSize(self) -> bool: 			return self.getDevicePropValue(DevicePropCode.ImageSize)
	def readApertureFNumber(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.FNumber)
	def readFocalLength(self) -> bool: 			return self.getDevicePropValue(DevicePropCode.FocalLength)
	def readFocusDistance(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.FocusDistance) 
	def readExposureIndex(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.ExposureIndex) 
	def readShutterSpeed(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.BMD_ShutterSpeed) 
	def readShutterAngle(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.BMD_ShutterAngle) 
	def readFocusPosition(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.BMD_FocusPosition) 
	def readWhiteBalance(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.BMD_WhiteBalanceKelvin) 
	def readTint(self) -> bool: 				return self.getDevicePropValue(DevicePropCode.BMD_WhiteBalanceTint) 
	def readFrameRate(self) -> bool: 			return self.getDevicePropValue(DevicePropCode.BMD_FrameRate) 
	def readOffSpeedFrameRate(self) -> bool: 	return self.getDevicePropValue(DevicePropCode.BMD_OffSpeedFrameRate) 
	def readOffSpeedEnabled(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.BMD_OffSpeedEnabled) 
	def readZoomPosition(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.BMD_ZoomPosition) 
	def readRecordingState(self) -> bool: 		return self.getDevicePropValue(DevicePropCode.BMD_RecordingState) 
	def readNDFilter(self) -> bool: 			return self.getDevicePropValue(DevicePropCode.BMD_NDFilter) 
	
	def writeDevicePropValue(self, devicePropCode: DevicePropCode, arg) -> bool:
		if self.m_isSessionOpened is False: return False
		
		Logger.Log("{} Device Prop Code: {}, Value: {}".format(inspect.stack()[1].function, DevicePropCodeType(devicePropCode.value), arg))
		if self.m_ptpEncoder.encodeSetDevicePropValueCommand(self.m_transactionId, devicePropCode, arg):
			return self.waitForResponse().responseCode == ResponseCode.OK
		
		return False
	
	def normalisedApertureToFNumber(self, normalisedAperture: float) -> fixedint.UInt16:
		deviceDescs = list(filter(lambda x: x.m_devicePropCode == DevicePropCode.FNumber, self.m_deviceDescs))
		if len(deviceDescs) > 0:
			deviceDesc = deviceDescs[0]
			fstops = [fixedint.UInt16(x) for x in deviceDesc.getEnumValues()]
			if len(fstops) == 0: return 0
			maxFstop = fixedint.UInt16(deviceDesc.getMaximumValue())
			minFstop = fixedint.UInt16(deviceDesc.getMinimumValue())
			currentfstop = fixedint.Int32((normalisedAperture * float(maxFstop - minFstop)) + float(minFstop))
			for nearest_index in range(len(fstops)): 
				if currentfstop <= fstops[nearest_index]: break
			prev = max(nearest_index - 1, 0)
			if (currentfstop - fstops[prev]) < (fstops[nearest_index] - currentfstop): nearest_index = prev
			return fstops[nearest_index]
        
		return 0
    
	def writeApertureNormalised(self, normalisedAperture: float) -> bool:
		return self.writeDevicePropValue(DevicePropCode.FNumber, self.normalisedApertureToFNumber(normalisedAperture))
	
	def incrementAperture(self, currentApertureNormalised: float) -> bool:
		deviceDescs = list(filter(lambda x: x.m_devicePropCode == DevicePropCode.FNumber, self.m_deviceDescs))
		if len(deviceDescs) > 0:
			deviceDesc = deviceDescs[0]
			fstops = [fixedint.UInt16(x) for x in deviceDesc.getEnumValues()]
			fstop = self.normalisedApertureToFNumber(currentApertureNormalised)
			currentIndex = fstops.index(fstop) if fstop in fstops else None
			if currentIndex is not None:
				fnumberX100 = fstops[min(currentIndex + 1, len(fstops) - 1)]
				return self.writeDevicePropValue(DevicePropCode.FNumber, fnumberX100)
                    
		return False

	def decrementAperture(self, currentApertureNormalised: float) -> bool:
		deviceDescs = list(filter(lambda x: x.m_devicePropCode == DevicePropCode.FNumber, self.m_deviceDescs))
		if len(deviceDescs) > 0:
			deviceDesc = deviceDescs[0]
			fstops = [fixedint.UInt16(x) for x in deviceDesc.getEnumValues()]
			fstop = self.normalisedApertureToFNumber(currentApertureNormalised)
			currentIndex = fstops.index(fstop) if fstop in fstops else None
			if currentIndex is not None:
				fnumberX100 = fstops[max(currentIndex - 1, 0)]
				return self.writeDevicePropValue(DevicePropCode.FNumber, fnumberX100)
                    
		return False
    
	def writeApertureFNumber(self, fnumberX100: fixedint.UInt16) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.FNumber, fnumberX100) 

	def writeFocalLength(self, focalLength: fixedint.UInt32) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.FocalLength, focalLength) 

	def writeFocusDistance(self, focusDistance: fixedint.UInt16) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.FocusDistance, focusDistance) 

	def writeExposureIndex(self, exposureIndex: fixedint.UInt16) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.ExposureIndex, exposureIndex) 

	def writeShutterSpeed(self, shutterSpeed: fixedint.UInt16) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.BMD_ShutterSpeed, shutterSpeed) 

	def writeShutterAngle(self, shutterAngle: fixedint.UInt16) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.BMD_ShutterAngle, shutterAngle) 

	def writeFocusPosition(self, focusPosition: fixedint.Int32) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.BMD_FocusPosition, focusPosition) 

	def writeWhiteBalance(self, whiteBalance: fixedint.UInt16) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.BMD_WhiteBalanceKelvin, whiteBalance) 

	def writeTint(self, tint: fixedint.Int8) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.BMD_WhiteBalanceTint, tint) 

	def writeFrameRate(self, frameRate: fixedint.UInt32) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.BMD_FrameRate, frameRate) 

	def writeOffSpeedFrameRate(self, offSpeedFrameRate: fixedint.UInt32) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.BMD_OffSpeedFrameRate, offSpeedFrameRate) 

	def writeZoomPosition(self, zoomPosition: fixedint.UInt16) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.BMD_ZoomPosition, zoomPosition) 

	def writeOffSpeedEnabled(self, offSpeedEnabled: bool) -> bool:
		kEnableOffSpeed, kDisableOffSpeed = fixedint.UInt32(1), fixedint.UInt32(0)
		return self.writeDevicePropValue(DevicePropCode.BMD_OffSpeedEnabled, kEnableOffSpeed if offSpeedEnabled else kDisableOffSpeed)
	
	def writeNDFilter(self, ndFilter: PTPTypes.ptp_fixed_t) -> bool: 
		return self.writeDevicePropValue(DevicePropCode.BMD_NDFilter, ndFilter) 
	

