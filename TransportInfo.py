# -LICENSE-START-
# Copyright (c) 2018 Blackmagic Design
# 
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
# 
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# -LICENSE-END-
#

import fixedint
from typing import List
from BaseEnum import *
from CCUPacketTypes import *

MediaTransportFlag = CCUPacketTypes.MediaTransportFlag

class TransportInfo:

	def __init__(self, data:List[fixedint.UInt8]=None):
		self.transportMode 			= CCUPacketTypes.MediaTransportMode.Preview
		self.speed:fixedint.Int8 	= 0

		self.loop 					= False
		self.playAll 				= False
		self.timelapseRecording 	= False

		class Slot:
			def __init__(self):
				self.active 	= False
				self.medium 	= CCUPacketTypes.ActiveStorageMedium.CFastCard

		self.slots					= [Slot]

		index = 0
		if data is None: raise ValueError("Unrecognised transport mode value {}".format(data[index]))
		if len(data) == 0: raise ValueError("Unrecognised transport mode value {}".format(data[index]))
		if data[index] in CCUPacketTypes.MediaTransportMode:
			mode = CCUPacketTypes.MediaTransportMode(data[index])
			self.transportMode = mode
			index += 1
			self.speed = fixedint.Int8(fixedint.UInt8(data[index]))
			index += 1

			flags = data[index]
			index += 1
			self.loop = ((flags & MediaTransportFlag.Loop.value) != 0)
			self.playAll = ((flags & MediaTransportFlag.PlayAll.value) != 0)
			self.timelapseRecording = ((flags & MediaTransportFlag.TimelapseRecording.value) != 0)

			slotCount = len(data) - index
			slots = [Slot() for i in range(slotCount)]
			for i in range(slotCount):
				slots[i].active = ((flags & CCUPacketTypes.slotActiveMasks[i]) != 0)
				if data[index] in CCUPacketTypes.ActiveStorageMedium:
					slots[i].medium = CCUPacketTypes.ActiveStorageMedium(data[index])
				else:
					Logger.LogWarning("Unrecognised storage medium value {} for slot {}".format(data[index], i))
				index += 1
		else:
			raise ValueError("Unrecognised transport mode value {}".format(data[index]))

	def getActiveSlotCount(self) -> fixedint.Int32:
		return len(list(filter(lambda x: x.active, self.slots)))

	def toArray(self) -> List[fixedint.UInt8]:
		# package flags
		flags:fixedint.UInt8 = 0
		if self.loop: flags |= MediaTransportFlag.Loop.value
		if self.playAll: flags |= MediaTransportFlag.PlayAll.value
		if self.timelapseRecording: flags |= MediaTransportFlag.TimelapseRecording.value

		for (i, slot) in self.slots: 
			if slot.active: flags |= CCUPacketTypes.slotActiveMasks[i]

		# package data
		data = []
		data.append(fixedint.UInt8(self.transportMode.value))
		data.append(fixedint.UInt8(self.speed))
		data.append(fixedint.UInt8(flags))
		for slot in self.slots: data.append(fixedint.UInt8(slot.medium.value))

		return data
