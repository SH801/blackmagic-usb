# -LICENSE-START-
# Copyright (c) 2020 Blackmagic Design
# 
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
# 
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# -LICENSE-END-
#

from queue import Queue, Empty as QueueEmpty
from StoppableThread import *
from LogFunctions import *
from PTPTypes import *
from USBVendorIDs import *
from USBBulkDevice import *
from USBDeviceNotifier import *

class USBManagerThread(StoppableThread):

	def __init__(self,  *args, **kwargs):
		super().__init__(*args, **kwargs)

	def setParameters(self, usbConnectionManager, queue):
		self.m_usbConnectionManager = usbConnectionManager
		self.task_queue = queue
	
	def notification(self, task):
		Logger.LogWithInfo("USBManagerThread: Notification started")

		match task['name']:
			case Notification.USBDeviceConnected:		
				self.m_usbConnectionManager.onUSBDeviceConnected(task['userInfo'])
			case Notification.USBDeviceDisconnected:	
				self.m_usbConnectionManager.onUSBDeviceDisconnected(task['userInfo'])

		Logger.LogWithInfo("USBManagerThread: Notification finished")

	def function(self, task):
		Logger.LogWithInfo("USBManagerThread: Function started {}".format(task['function'].__name__))

		if self.m_usbConnectionManager.m_USBConnectionManagerDelegate is None:
			Logger.LogWithInfo("USBManagerThread: m_USBConnectionManagerDelegate not set, cannot call function")
		else:
			task['function'](*task['parameters'])

		Logger.LogWithInfo("USBManagerThread: Function finished")	

	def run(self):
		Logger.ThreadLogWithInfo("USBManagerThread: started")
		
		while not self.stopped():
			# Logger.ThreadLogWithInfo("USBManagerThread: waiting for queue item")
			try:
				task = self.task_queue.get(timeout=1)
				Logger.ThreadLogWithInfo("USBManagerThread: received queue item")
				try:
					match(task['type']):
						case "Notification":	self.notification(task)
						case "Function": 		self.function(task)
				finally: 
					self.task_queue.task_done()
			except QueueEmpty: 
				pass

		Logger.ThreadLogWithInfo("USBManagerThread: stopped")
		
class USBConnectionManager():
	
	def __init__(self, usbContext):

		# Properties
		self.m_usbContext = usbContext
		self.m_usbManagerQueue = Queue()
		self.m_usbManagerThread = USBManagerThread(name="USBManagerThread")
		self.m_usbManagerThread.setParameters(usbConnectionManager=self, queue=self.m_usbManagerQueue)

		self.m_usbDeviceNotifier = USBDeviceNotifier(self.m_usbContext, self.m_usbManagerQueue)
		self.m_discoveredUSBPTPDevices = []
		self.m_USBConnectionManagerDelegate = None
		self.m_connectedDevice: USBBulkDevice = None
		
		# Filter to get notifications only of Blackmagic Design USB devices with PTP support
		self.m_usbDeviceNotifier.addFilterVendorId(kBlackmagicDesignVendorID)
		self.m_usbDeviceNotifier.addFilterInterface(PTPTypes().kUSBInterfaceClass, PTPTypes().kUSBInterfaceSubClass)

		self.start()

	def start(self):
		if self.m_usbManagerThread is not None:
			self.m_usbManagerThread.start()

		if self.m_usbDeviceNotifier is not None:
			self.m_usbDeviceNotifier.start()

	def stop(self):
		if self.m_connectedDevice is not None:
			Logger.LogWithInfo("Closing open USB device")
			self.closeDevice()
			Logger.ThreadLogWithInfo("Closed open USB device")

		if self.m_usbDeviceNotifier is not None:
			Logger.ThreadLogWithInfo("Stopping USB device notifier")
			self.m_usbDeviceNotifier.stop()		
			self.m_usbDeviceNotifier = None

		if self.m_usbManagerThread is not None:
			Logger.ThreadLogWithInfo("Sending shutdown to USBManagerThread")	
			self.m_usbManagerThread.stop()
			self.m_usbManagerThread.join()
			self.m_usbManagerThread = None

		Logger.LogWithInfo("Shutdown complete")
		
	def __del__(self):
		self.stop()

	def setDelegate(self, delegate):
		self.m_USBConnectionManagerDelegate = delegate
	
	def openDevice(self, device: USBBulkDevice):
		Logger.LogWithInfo("openDevice")
		if self.m_connectedDevice is None: 
			if device.open():
				self.m_connectedDevice = device
				Logger.LogWithInfo("calling connectToUSBDevice")
				self.m_USBConnectionManagerDelegate.connectedToUSBDevice(device)				
				Logger.LogWithInfo("Opened device {}".format(device.getName()))
				return True
		
		return False

	def closeDevice(self):
		self.m_connectedDevice.close()
		self.m_connectedDevice = None
		self.m_usbManagerQueue.put_nowait({	'type': 		'Function', \
												'function': 	self.m_USBConnectionManagerDelegate.disconnectedFromUSBDevice, \
												'parameters': 	()})
	
	def getDiscoveredUSBPTPDevices(self):
		return self.m_discoveredUSBPTPDevices

	def discoveredUSBPTPDevices(self):
		self.m_USBConnectionManagerDelegate.updateDiscoveredUSBPTPDevices(self.m_discoveredUSBPTPDevices)
		if self.m_connectedDevice is None: return
		if list(filter(lambda x: x.getId() == self.m_connectedDevice.getId(), self.m_discoveredUSBPTPDevices)) is None:
			self.m_connectedDevice = None
			self.m_USBConnectionManagerDelegate.disconnectedFromUSBDevice()

	def informDiscoveredUSBPTPDevices(self):
		self.m_usbManagerQueue.put_nowait({	'type': 		'Function', \
												'function': 	self.discoveredUSBPTPDevices, \
												'parameters': 	()})
	
	# =======================================================
	# Notification Center
	# =======================================================
	def onUSBDeviceConnected(self, userInfo):
		device = userInfo['device']
		Logger.LogWithInfo("Device Added: ID: {}".format(device.getId()))

		if device not in self.m_discoveredUSBPTPDevices:
			self.m_discoveredUSBPTPDevices.append(device)

		self.informDiscoveredUSBPTPDevices()
	
	def onUSBDeviceDisconnected(self, userInfo):
		deviceId = userInfo['id']
		Logger.LogWithInfo("Device Removed: ID: {}".format(deviceId))
		
		if (self.m_connectedDevice is None):
			Logger.LogError("m_connectedDevice is not set - cannot disconnect")
			return
		
		if (self.m_connectedDevice.getId() == deviceId):
			self.closeDevice()

		self.m_discoveredUSBPTPDevices = list(filter(lambda x: x.getId() != deviceId, self.m_discoveredUSBPTPDevices))

		self.informDiscoveredUSBPTPDevices()
